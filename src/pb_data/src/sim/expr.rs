// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExprNode {
    /// Only use this field for function call. For other types of expression, it should be UNSPECIFIED.
    #[prost(enumeration = "expr_node::Type", tag = "1")]
    pub function_type: i32,
    #[prost(message, optional, tag = "3")]
    pub return_type: ::core::option::Option<super::data::DataType>,
    #[prost(oneof = "expr_node::RexNode", tags = "4, 5, 6, 7, 8")]
    pub rex_node: ::core::option::Option<expr_node::RexNode>,
}
/// Nested message and enum types in `ExprNode`.
pub mod expr_node {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct NowRexNode {}
    /// TODO: move this into `FunctionCall`.
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        /// Used for `InputRef`, `Constant`, and `UserDefinedFunction`.
        Unspecified = 0,
        /// arithmetics operators
        Add = 3,
        Subtract = 4,
        Multiply = 5,
        Divide = 6,
        Modulus = 7,
        /// comparison operators
        Equal = 8,
        NotEqual = 9,
        LessThan = 10,
        LessThanOrEqual = 11,
        GreaterThan = 12,
        GreaterThanOrEqual = 13,
        Greatest = 14,
        Least = 15,
        /// logical operators
        And = 21,
        Or = 22,
        Not = 23,
        In = 24,
        Some = 25,
        All = 26,
        /// bitwise operators
        BitwiseAnd = 31,
        BitwiseOr = 32,
        BitwiseXor = 33,
        BitwiseNot = 34,
        BitwiseShiftLeft = 35,
        BitwiseShiftRight = 36,
        /// date/time functions
        Extract = 101,
        DatePart = 102,
        TumbleStart = 103,
        MakeDate = 113,
        MakeTime = 114,
        MakeTimestamp = 115,
        DateBin = 116,
        /// From f64 to timestamp.
        /// e.g. `select to_timestamp(1672044740.0)`
        SecToTimestamptz = 104,
        AtTimeZone = 105,
        DateTrunc = 106,
        /// Parse text to timestamp by format string.
        /// e.g. `select to_timestamp('2022 08 21', 'YYYY MM DD')`
        CharToTimestamptz = 107,
        CharToDate = 111,
        /// Performs a cast with additional timezone information.
        CastWithTimeZone = 108,
        AddWithTimeZone = 109,
        SubtractWithTimeZone = 110,
        MakeTimestamptz = 112,
        /// other functions
        Cast = 201,
        Substr = 202,
        Length = 203,
        Like = 204,
        ILike = 279,
        SimilarToEscape = 284,
        Upper = 205,
        Lower = 206,
        Trim = 207,
        Replace = 208,
        Position = 209,
        Ltrim = 210,
        Rtrim = 211,
        Case = 212,
        /// Optimize case-when expression to constant lookup
        /// when arms are in a large scale with simple form
        ConstantLookup = 624,
        /// ROUND(numeric, integer) -> numeric
        RoundDigit = 213,
        /// ROUND(numeric) -> numeric
        /// ROUND(double precision) -> double precision
        Round = 214,
        Ascii = 215,
        Translate = 216,
        Coalesce = 217,
        ConcatWs = 218,
        ConcatWsVariadic = 285,
        Abs = 219,
        SplitPart = 220,
        Ceil = 221,
        Floor = 222,
        ToChar = 223,
        Md5 = 224,
        CharLength = 225,
        Repeat = 226,
        ConcatOp = 227,
        Concat = 286,
        ConcatVariadic = 287,
        /// BOOL_OUT is different from CAST-bool-to-varchar in PostgreSQL.
        BoolOut = 228,
        OctetLength = 229,
        BitLength = 230,
        Overlay = 231,
        RegexpMatch = 232,
        RegexpReplace = 280,
        RegexpCount = 281,
        RegexpSplitToArray = 282,
        RegexpEq = 283,
        Pow = 233,
        Exp = 234,
        Chr = 235,
        StartsWith = 236,
        Initcap = 237,
        Lpad = 238,
        Rpad = 239,
        Reverse = 240,
        /// duplicated with POSITION
        Strpos = 241,
        ToAscii = 242,
        ToHex = 243,
        QuoteIdent = 244,
        Sin = 245,
        Cos = 246,
        Tan = 247,
        Cot = 248,
        Asin = 249,
        Acos = 250,
        Atan = 251,
        Atan2 = 252,
        Sind = 253,
        Cosd = 254,
        Cotd = 255,
        Tand = 256,
        Asind = 257,
        Sqrt = 258,
        Degrees = 259,
        Radians = 260,
        Cosh = 261,
        Tanh = 262,
        Coth = 263,
        Asinh = 264,
        Acosh = 265,
        Atanh = 266,
        Sinh = 267,
        Acosd = 268,
        Atand = 269,
        Atan2d = 270,
        Trunc = 271,
        Ln = 272,
        Log10 = 273,
        Cbrt = 274,
        Sign = 275,
        Scale = 276,
        MinScale = 277,
        TrimScale = 278,
        /// Boolean comparison
        IsTrue = 301,
        IsNotTrue = 302,
        IsFalse = 303,
        IsNotFalse = 304,
        IsNull = 305,
        IsNotNull = 306,
        IsDistinctFrom = 307,
        IsNotDistinctFrom = 308,
        /// string/bytea expressions
        Encode = 310,
        Decode = 311,
        Sha1 = 312,
        Sha224 = 313,
        Sha256 = 314,
        Sha384 = 315,
        Sha512 = 316,
        Left = 317,
        Right = 318,
        Format = 319,
        FormatVariadic = 326,
        PgwireSend = 320,
        PgwireRecv = 321,
        ConvertFrom = 322,
        ConvertTo = 323,
        Decrypt = 324,
        Encrypt = 325,
        InetAton = 328,
        InetNtoa = 329,
        QuoteLiteral = 330,
        QuoteNullable = 331,
        Hmac = 332,
        SecureCompare = 333,
        /// Constraints Check
        CheckNotNull = 350,
        /// Unary operators
        Neg = 401,
        /// Nested selection operators
        Field = 501,
        /// Array expression.
        Array = 521,
        ArrayAccess = 522,
        Row = 523,
        ArrayToString = 524,
        ArrayRangeAccess = 525,
        /// Array functions
        ArrayCat = 531,
        ArrayAppend = 532,
        ArrayPrepend = 533,
        FormatType = 534,
        ArrayDistinct = 535,
        ArrayLength = 536,
        Cardinality = 537,
        ArrayRemove = 538,
        ArrayPositions = 539,
        TrimArray = 540,
        StringToArray = 541,
        ArrayPosition = 542,
        ArrayReplace = 543,
        ArrayDims = 544,
        ArrayTransform = 545,
        ArrayMin = 546,
        ArrayMax = 547,
        ArraySum = 548,
        ArraySort = 549,
        ArrayContains = 550,
        ArrayContained = 551,
        ArrayFlatten = 552,
        /// Int256 functions
        HexToInt256 = 560,
        /// jsonb -> int, jsonb -> text that returns jsonb
        JsonbAccess = 600,
        /// jsonb ->> int, jsonb ->> text that returns text
        JsonbAccessStr = 601,
        /// jsonb #> text\[\] -> jsonb
        JsonbExtractPath = 627,
        JsonbExtractPathVariadic = 613,
        /// jsonb #>> text\[\] -> text
        JsonbExtractPathText = 628,
        JsonbExtractPathTextVariadic = 614,
        JsonbTypeof = 602,
        JsonbArrayLength = 603,
        IsJson = 604,
        JsonbConcat = 605,
        JsonbObject = 606,
        JsonbPretty = 607,
        /// jsonb @> jsonb
        JsonbContains = 608,
        /// jsonb <@ jsonb
        JsonbContained = 609,
        /// jsonb ? text
        JsonbExists = 610,
        /// jsonb ?| text\[\]
        JsonbExistsAny = 611,
        /// jsonb ?& text\[\]
        JsonbExistsAll = 612,
        /// see SUBTRACT for:
        /// jsonb - text -> jsonb
        /// jsonb - text\[\] -> jsonb
        /// jsonb - integer -> jsonb
        ///
        /// jsonb #- text\[\] -> jsonb
        JsonbDeletePath = 615,
        JsonbStripNulls = 616,
        ToJsonb = 617,
        JsonbBuildArray = 618,
        JsonbBuildArrayVariadic = 625,
        JsonbBuildObject = 619,
        JsonbBuildObjectVariadic = 626,
        JsonbPathExists = 620,
        JsonbPathMatch = 621,
        JsonbPathQueryArray = 622,
        JsonbPathQueryFirst = 623,
        JsonbPopulateRecord = 629,
        JsonbToRecord = 630,
        JsonbSet = 631,
        JsonbPopulateMap = 632,
        /// Map functions
        MapFromEntries = 700,
        MapAccess = 701,
        MapKeys = 702,
        MapValues = 703,
        MapEntries = 704,
        MapFromKeyValues = 705,
        MapLength = 706,
        MapContains = 707,
        MapCat = 708,
        MapInsert = 709,
        MapDelete = 710,
        /// Internal function for schema change
        CompositeCast = 800,
        /// Non-pure functions below (> 1000)
        /// ------------------------
        /// Internal functions
        Vnode = 1101,
        TestPaidTier = 1102,
        VnodeUser = 1103,
        License = 1104,
        /// Non-deterministic functions
        Proctime = 2023,
        PgSleep = 2024,
        PgSleepFor = 2025,
        PgSleepUntil = 2026,
        /// System administration functions
        CastRegclass = 2100,
        /// System information functions
        PgGetIndexdef = 2400,
        ColDescription = 2401,
        PgGetViewdef = 2402,
        PgGetUserbyid = 2403,
        PgIndexesSize = 2404,
        PgRelationSize = 2405,
        PgGetSerialSequence = 2406,
        PgIndexColumnHasProperty = 2410,
        HasTablePrivilege = 2407,
        HasAnyColumnPrivilege = 2408,
        HasSchemaPrivilege = 2409,
        PgIsInRecovery = 2411,
        RwRecoveryStatus = 2412,
        RwEpochToTs = 2413,
        PgTableIsVisible = 2414,
        HasFunctionPrivilege = 2415,
        /// EXTERNAL
        IcebergTransform = 2201,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Add => "ADD",
                Self::Subtract => "SUBTRACT",
                Self::Multiply => "MULTIPLY",
                Self::Divide => "DIVIDE",
                Self::Modulus => "MODULUS",
                Self::Equal => "EQUAL",
                Self::NotEqual => "NOT_EQUAL",
                Self::LessThan => "LESS_THAN",
                Self::LessThanOrEqual => "LESS_THAN_OR_EQUAL",
                Self::GreaterThan => "GREATER_THAN",
                Self::GreaterThanOrEqual => "GREATER_THAN_OR_EQUAL",
                Self::Greatest => "GREATEST",
                Self::Least => "LEAST",
                Self::And => "AND",
                Self::Or => "OR",
                Self::Not => "NOT",
                Self::In => "IN",
                Self::Some => "SOME",
                Self::All => "ALL",
                Self::BitwiseAnd => "BITWISE_AND",
                Self::BitwiseOr => "BITWISE_OR",
                Self::BitwiseXor => "BITWISE_XOR",
                Self::BitwiseNot => "BITWISE_NOT",
                Self::BitwiseShiftLeft => "BITWISE_SHIFT_LEFT",
                Self::BitwiseShiftRight => "BITWISE_SHIFT_RIGHT",
                Self::Extract => "EXTRACT",
                Self::DatePart => "DATE_PART",
                Self::TumbleStart => "TUMBLE_START",
                Self::MakeDate => "MAKE_DATE",
                Self::MakeTime => "MAKE_TIME",
                Self::MakeTimestamp => "MAKE_TIMESTAMP",
                Self::DateBin => "DATE_BIN",
                Self::SecToTimestamptz => "SEC_TO_TIMESTAMPTZ",
                Self::AtTimeZone => "AT_TIME_ZONE",
                Self::DateTrunc => "DATE_TRUNC",
                Self::CharToTimestamptz => "CHAR_TO_TIMESTAMPTZ",
                Self::CharToDate => "CHAR_TO_DATE",
                Self::CastWithTimeZone => "CAST_WITH_TIME_ZONE",
                Self::AddWithTimeZone => "ADD_WITH_TIME_ZONE",
                Self::SubtractWithTimeZone => "SUBTRACT_WITH_TIME_ZONE",
                Self::MakeTimestamptz => "MAKE_TIMESTAMPTZ",
                Self::Cast => "CAST",
                Self::Substr => "SUBSTR",
                Self::Length => "LENGTH",
                Self::Like => "LIKE",
                Self::ILike => "I_LIKE",
                Self::SimilarToEscape => "SIMILAR_TO_ESCAPE",
                Self::Upper => "UPPER",
                Self::Lower => "LOWER",
                Self::Trim => "TRIM",
                Self::Replace => "REPLACE",
                Self::Position => "POSITION",
                Self::Ltrim => "LTRIM",
                Self::Rtrim => "RTRIM",
                Self::Case => "CASE",
                Self::ConstantLookup => "CONSTANT_LOOKUP",
                Self::RoundDigit => "ROUND_DIGIT",
                Self::Round => "ROUND",
                Self::Ascii => "ASCII",
                Self::Translate => "TRANSLATE",
                Self::Coalesce => "COALESCE",
                Self::ConcatWs => "CONCAT_WS",
                Self::ConcatWsVariadic => "CONCAT_WS_VARIADIC",
                Self::Abs => "ABS",
                Self::SplitPart => "SPLIT_PART",
                Self::Ceil => "CEIL",
                Self::Floor => "FLOOR",
                Self::ToChar => "TO_CHAR",
                Self::Md5 => "MD5",
                Self::CharLength => "CHAR_LENGTH",
                Self::Repeat => "REPEAT",
                Self::ConcatOp => "CONCAT_OP",
                Self::Concat => "CONCAT",
                Self::ConcatVariadic => "CONCAT_VARIADIC",
                Self::BoolOut => "BOOL_OUT",
                Self::OctetLength => "OCTET_LENGTH",
                Self::BitLength => "BIT_LENGTH",
                Self::Overlay => "OVERLAY",
                Self::RegexpMatch => "REGEXP_MATCH",
                Self::RegexpReplace => "REGEXP_REPLACE",
                Self::RegexpCount => "REGEXP_COUNT",
                Self::RegexpSplitToArray => "REGEXP_SPLIT_TO_ARRAY",
                Self::RegexpEq => "REGEXP_EQ",
                Self::Pow => "POW",
                Self::Exp => "EXP",
                Self::Chr => "CHR",
                Self::StartsWith => "STARTS_WITH",
                Self::Initcap => "INITCAP",
                Self::Lpad => "LPAD",
                Self::Rpad => "RPAD",
                Self::Reverse => "REVERSE",
                Self::Strpos => "STRPOS",
                Self::ToAscii => "TO_ASCII",
                Self::ToHex => "TO_HEX",
                Self::QuoteIdent => "QUOTE_IDENT",
                Self::Sin => "SIN",
                Self::Cos => "COS",
                Self::Tan => "TAN",
                Self::Cot => "COT",
                Self::Asin => "ASIN",
                Self::Acos => "ACOS",
                Self::Atan => "ATAN",
                Self::Atan2 => "ATAN2",
                Self::Sind => "SIND",
                Self::Cosd => "COSD",
                Self::Cotd => "COTD",
                Self::Tand => "TAND",
                Self::Asind => "ASIND",
                Self::Sqrt => "SQRT",
                Self::Degrees => "DEGREES",
                Self::Radians => "RADIANS",
                Self::Cosh => "COSH",
                Self::Tanh => "TANH",
                Self::Coth => "COTH",
                Self::Asinh => "ASINH",
                Self::Acosh => "ACOSH",
                Self::Atanh => "ATANH",
                Self::Sinh => "SINH",
                Self::Acosd => "ACOSD",
                Self::Atand => "ATAND",
                Self::Atan2d => "ATAN2D",
                Self::Trunc => "TRUNC",
                Self::Ln => "LN",
                Self::Log10 => "LOG10",
                Self::Cbrt => "CBRT",
                Self::Sign => "SIGN",
                Self::Scale => "SCALE",
                Self::MinScale => "MIN_SCALE",
                Self::TrimScale => "TRIM_SCALE",
                Self::IsTrue => "IS_TRUE",
                Self::IsNotTrue => "IS_NOT_TRUE",
                Self::IsFalse => "IS_FALSE",
                Self::IsNotFalse => "IS_NOT_FALSE",
                Self::IsNull => "IS_NULL",
                Self::IsNotNull => "IS_NOT_NULL",
                Self::IsDistinctFrom => "IS_DISTINCT_FROM",
                Self::IsNotDistinctFrom => "IS_NOT_DISTINCT_FROM",
                Self::Encode => "ENCODE",
                Self::Decode => "DECODE",
                Self::Sha1 => "SHA1",
                Self::Sha224 => "SHA224",
                Self::Sha256 => "SHA256",
                Self::Sha384 => "SHA384",
                Self::Sha512 => "SHA512",
                Self::Left => "LEFT",
                Self::Right => "RIGHT",
                Self::Format => "FORMAT",
                Self::FormatVariadic => "FORMAT_VARIADIC",
                Self::PgwireSend => "PGWIRE_SEND",
                Self::PgwireRecv => "PGWIRE_RECV",
                Self::ConvertFrom => "CONVERT_FROM",
                Self::ConvertTo => "CONVERT_TO",
                Self::Decrypt => "DECRYPT",
                Self::Encrypt => "ENCRYPT",
                Self::InetAton => "INET_ATON",
                Self::InetNtoa => "INET_NTOA",
                Self::QuoteLiteral => "QUOTE_LITERAL",
                Self::QuoteNullable => "QUOTE_NULLABLE",
                Self::Hmac => "HMAC",
                Self::SecureCompare => "SECURE_COMPARE",
                Self::CheckNotNull => "CHECK_NOT_NULL",
                Self::Neg => "NEG",
                Self::Field => "FIELD",
                Self::Array => "ARRAY",
                Self::ArrayAccess => "ARRAY_ACCESS",
                Self::Row => "ROW",
                Self::ArrayToString => "ARRAY_TO_STRING",
                Self::ArrayRangeAccess => "ARRAY_RANGE_ACCESS",
                Self::ArrayCat => "ARRAY_CAT",
                Self::ArrayAppend => "ARRAY_APPEND",
                Self::ArrayPrepend => "ARRAY_PREPEND",
                Self::FormatType => "FORMAT_TYPE",
                Self::ArrayDistinct => "ARRAY_DISTINCT",
                Self::ArrayLength => "ARRAY_LENGTH",
                Self::Cardinality => "CARDINALITY",
                Self::ArrayRemove => "ARRAY_REMOVE",
                Self::ArrayPositions => "ARRAY_POSITIONS",
                Self::TrimArray => "TRIM_ARRAY",
                Self::StringToArray => "STRING_TO_ARRAY",
                Self::ArrayPosition => "ARRAY_POSITION",
                Self::ArrayReplace => "ARRAY_REPLACE",
                Self::ArrayDims => "ARRAY_DIMS",
                Self::ArrayTransform => "ARRAY_TRANSFORM",
                Self::ArrayMin => "ARRAY_MIN",
                Self::ArrayMax => "ARRAY_MAX",
                Self::ArraySum => "ARRAY_SUM",
                Self::ArraySort => "ARRAY_SORT",
                Self::ArrayContains => "ARRAY_CONTAINS",
                Self::ArrayContained => "ARRAY_CONTAINED",
                Self::ArrayFlatten => "ARRAY_FLATTEN",
                Self::HexToInt256 => "HEX_TO_INT256",
                Self::JsonbAccess => "JSONB_ACCESS",
                Self::JsonbAccessStr => "JSONB_ACCESS_STR",
                Self::JsonbExtractPath => "JSONB_EXTRACT_PATH",
                Self::JsonbExtractPathVariadic => "JSONB_EXTRACT_PATH_VARIADIC",
                Self::JsonbExtractPathText => "JSONB_EXTRACT_PATH_TEXT",
                Self::JsonbExtractPathTextVariadic => "JSONB_EXTRACT_PATH_TEXT_VARIADIC",
                Self::JsonbTypeof => "JSONB_TYPEOF",
                Self::JsonbArrayLength => "JSONB_ARRAY_LENGTH",
                Self::IsJson => "IS_JSON",
                Self::JsonbConcat => "JSONB_CONCAT",
                Self::JsonbObject => "JSONB_OBJECT",
                Self::JsonbPretty => "JSONB_PRETTY",
                Self::JsonbContains => "JSONB_CONTAINS",
                Self::JsonbContained => "JSONB_CONTAINED",
                Self::JsonbExists => "JSONB_EXISTS",
                Self::JsonbExistsAny => "JSONB_EXISTS_ANY",
                Self::JsonbExistsAll => "JSONB_EXISTS_ALL",
                Self::JsonbDeletePath => "JSONB_DELETE_PATH",
                Self::JsonbStripNulls => "JSONB_STRIP_NULLS",
                Self::ToJsonb => "TO_JSONB",
                Self::JsonbBuildArray => "JSONB_BUILD_ARRAY",
                Self::JsonbBuildArrayVariadic => "JSONB_BUILD_ARRAY_VARIADIC",
                Self::JsonbBuildObject => "JSONB_BUILD_OBJECT",
                Self::JsonbBuildObjectVariadic => "JSONB_BUILD_OBJECT_VARIADIC",
                Self::JsonbPathExists => "JSONB_PATH_EXISTS",
                Self::JsonbPathMatch => "JSONB_PATH_MATCH",
                Self::JsonbPathQueryArray => "JSONB_PATH_QUERY_ARRAY",
                Self::JsonbPathQueryFirst => "JSONB_PATH_QUERY_FIRST",
                Self::JsonbPopulateRecord => "JSONB_POPULATE_RECORD",
                Self::JsonbToRecord => "JSONB_TO_RECORD",
                Self::JsonbSet => "JSONB_SET",
                Self::JsonbPopulateMap => "JSONB_POPULATE_MAP",
                Self::MapFromEntries => "MAP_FROM_ENTRIES",
                Self::MapAccess => "MAP_ACCESS",
                Self::MapKeys => "MAP_KEYS",
                Self::MapValues => "MAP_VALUES",
                Self::MapEntries => "MAP_ENTRIES",
                Self::MapFromKeyValues => "MAP_FROM_KEY_VALUES",
                Self::MapLength => "MAP_LENGTH",
                Self::MapContains => "MAP_CONTAINS",
                Self::MapCat => "MAP_CAT",
                Self::MapInsert => "MAP_INSERT",
                Self::MapDelete => "MAP_DELETE",
                Self::CompositeCast => "COMPOSITE_CAST",
                Self::Vnode => "VNODE",
                Self::TestPaidTier => "TEST_PAID_TIER",
                Self::VnodeUser => "VNODE_USER",
                Self::License => "LICENSE",
                Self::Proctime => "PROCTIME",
                Self::PgSleep => "PG_SLEEP",
                Self::PgSleepFor => "PG_SLEEP_FOR",
                Self::PgSleepUntil => "PG_SLEEP_UNTIL",
                Self::CastRegclass => "CAST_REGCLASS",
                Self::PgGetIndexdef => "PG_GET_INDEXDEF",
                Self::ColDescription => "COL_DESCRIPTION",
                Self::PgGetViewdef => "PG_GET_VIEWDEF",
                Self::PgGetUserbyid => "PG_GET_USERBYID",
                Self::PgIndexesSize => "PG_INDEXES_SIZE",
                Self::PgRelationSize => "PG_RELATION_SIZE",
                Self::PgGetSerialSequence => "PG_GET_SERIAL_SEQUENCE",
                Self::PgIndexColumnHasProperty => "PG_INDEX_COLUMN_HAS_PROPERTY",
                Self::HasTablePrivilege => "HAS_TABLE_PRIVILEGE",
                Self::HasAnyColumnPrivilege => "HAS_ANY_COLUMN_PRIVILEGE",
                Self::HasSchemaPrivilege => "HAS_SCHEMA_PRIVILEGE",
                Self::PgIsInRecovery => "PG_IS_IN_RECOVERY",
                Self::RwRecoveryStatus => "RW_RECOVERY_STATUS",
                Self::RwEpochToTs => "RW_EPOCH_TO_TS",
                Self::PgTableIsVisible => "PG_TABLE_IS_VISIBLE",
                Self::HasFunctionPrivilege => "HAS_FUNCTION_PRIVILEGE",
                Self::IcebergTransform => "ICEBERG_TRANSFORM",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ADD" => Some(Self::Add),
                "SUBTRACT" => Some(Self::Subtract),
                "MULTIPLY" => Some(Self::Multiply),
                "DIVIDE" => Some(Self::Divide),
                "MODULUS" => Some(Self::Modulus),
                "EQUAL" => Some(Self::Equal),
                "NOT_EQUAL" => Some(Self::NotEqual),
                "LESS_THAN" => Some(Self::LessThan),
                "LESS_THAN_OR_EQUAL" => Some(Self::LessThanOrEqual),
                "GREATER_THAN" => Some(Self::GreaterThan),
                "GREATER_THAN_OR_EQUAL" => Some(Self::GreaterThanOrEqual),
                "GREATEST" => Some(Self::Greatest),
                "LEAST" => Some(Self::Least),
                "AND" => Some(Self::And),
                "OR" => Some(Self::Or),
                "NOT" => Some(Self::Not),
                "IN" => Some(Self::In),
                "SOME" => Some(Self::Some),
                "ALL" => Some(Self::All),
                "BITWISE_AND" => Some(Self::BitwiseAnd),
                "BITWISE_OR" => Some(Self::BitwiseOr),
                "BITWISE_XOR" => Some(Self::BitwiseXor),
                "BITWISE_NOT" => Some(Self::BitwiseNot),
                "BITWISE_SHIFT_LEFT" => Some(Self::BitwiseShiftLeft),
                "BITWISE_SHIFT_RIGHT" => Some(Self::BitwiseShiftRight),
                "EXTRACT" => Some(Self::Extract),
                "DATE_PART" => Some(Self::DatePart),
                "TUMBLE_START" => Some(Self::TumbleStart),
                "MAKE_DATE" => Some(Self::MakeDate),
                "MAKE_TIME" => Some(Self::MakeTime),
                "MAKE_TIMESTAMP" => Some(Self::MakeTimestamp),
                "DATE_BIN" => Some(Self::DateBin),
                "SEC_TO_TIMESTAMPTZ" => Some(Self::SecToTimestamptz),
                "AT_TIME_ZONE" => Some(Self::AtTimeZone),
                "DATE_TRUNC" => Some(Self::DateTrunc),
                "CHAR_TO_TIMESTAMPTZ" => Some(Self::CharToTimestamptz),
                "CHAR_TO_DATE" => Some(Self::CharToDate),
                "CAST_WITH_TIME_ZONE" => Some(Self::CastWithTimeZone),
                "ADD_WITH_TIME_ZONE" => Some(Self::AddWithTimeZone),
                "SUBTRACT_WITH_TIME_ZONE" => Some(Self::SubtractWithTimeZone),
                "MAKE_TIMESTAMPTZ" => Some(Self::MakeTimestamptz),
                "CAST" => Some(Self::Cast),
                "SUBSTR" => Some(Self::Substr),
                "LENGTH" => Some(Self::Length),
                "LIKE" => Some(Self::Like),
                "I_LIKE" => Some(Self::ILike),
                "SIMILAR_TO_ESCAPE" => Some(Self::SimilarToEscape),
                "UPPER" => Some(Self::Upper),
                "LOWER" => Some(Self::Lower),
                "TRIM" => Some(Self::Trim),
                "REPLACE" => Some(Self::Replace),
                "POSITION" => Some(Self::Position),
                "LTRIM" => Some(Self::Ltrim),
                "RTRIM" => Some(Self::Rtrim),
                "CASE" => Some(Self::Case),
                "CONSTANT_LOOKUP" => Some(Self::ConstantLookup),
                "ROUND_DIGIT" => Some(Self::RoundDigit),
                "ROUND" => Some(Self::Round),
                "ASCII" => Some(Self::Ascii),
                "TRANSLATE" => Some(Self::Translate),
                "COALESCE" => Some(Self::Coalesce),
                "CONCAT_WS" => Some(Self::ConcatWs),
                "CONCAT_WS_VARIADIC" => Some(Self::ConcatWsVariadic),
                "ABS" => Some(Self::Abs),
                "SPLIT_PART" => Some(Self::SplitPart),
                "CEIL" => Some(Self::Ceil),
                "FLOOR" => Some(Self::Floor),
                "TO_CHAR" => Some(Self::ToChar),
                "MD5" => Some(Self::Md5),
                "CHAR_LENGTH" => Some(Self::CharLength),
                "REPEAT" => Some(Self::Repeat),
                "CONCAT_OP" => Some(Self::ConcatOp),
                "CONCAT" => Some(Self::Concat),
                "CONCAT_VARIADIC" => Some(Self::ConcatVariadic),
                "BOOL_OUT" => Some(Self::BoolOut),
                "OCTET_LENGTH" => Some(Self::OctetLength),
                "BIT_LENGTH" => Some(Self::BitLength),
                "OVERLAY" => Some(Self::Overlay),
                "REGEXP_MATCH" => Some(Self::RegexpMatch),
                "REGEXP_REPLACE" => Some(Self::RegexpReplace),
                "REGEXP_COUNT" => Some(Self::RegexpCount),
                "REGEXP_SPLIT_TO_ARRAY" => Some(Self::RegexpSplitToArray),
                "REGEXP_EQ" => Some(Self::RegexpEq),
                "POW" => Some(Self::Pow),
                "EXP" => Some(Self::Exp),
                "CHR" => Some(Self::Chr),
                "STARTS_WITH" => Some(Self::StartsWith),
                "INITCAP" => Some(Self::Initcap),
                "LPAD" => Some(Self::Lpad),
                "RPAD" => Some(Self::Rpad),
                "REVERSE" => Some(Self::Reverse),
                "STRPOS" => Some(Self::Strpos),
                "TO_ASCII" => Some(Self::ToAscii),
                "TO_HEX" => Some(Self::ToHex),
                "QUOTE_IDENT" => Some(Self::QuoteIdent),
                "SIN" => Some(Self::Sin),
                "COS" => Some(Self::Cos),
                "TAN" => Some(Self::Tan),
                "COT" => Some(Self::Cot),
                "ASIN" => Some(Self::Asin),
                "ACOS" => Some(Self::Acos),
                "ATAN" => Some(Self::Atan),
                "ATAN2" => Some(Self::Atan2),
                "SIND" => Some(Self::Sind),
                "COSD" => Some(Self::Cosd),
                "COTD" => Some(Self::Cotd),
                "TAND" => Some(Self::Tand),
                "ASIND" => Some(Self::Asind),
                "SQRT" => Some(Self::Sqrt),
                "DEGREES" => Some(Self::Degrees),
                "RADIANS" => Some(Self::Radians),
                "COSH" => Some(Self::Cosh),
                "TANH" => Some(Self::Tanh),
                "COTH" => Some(Self::Coth),
                "ASINH" => Some(Self::Asinh),
                "ACOSH" => Some(Self::Acosh),
                "ATANH" => Some(Self::Atanh),
                "SINH" => Some(Self::Sinh),
                "ACOSD" => Some(Self::Acosd),
                "ATAND" => Some(Self::Atand),
                "ATAN2D" => Some(Self::Atan2d),
                "TRUNC" => Some(Self::Trunc),
                "LN" => Some(Self::Ln),
                "LOG10" => Some(Self::Log10),
                "CBRT" => Some(Self::Cbrt),
                "SIGN" => Some(Self::Sign),
                "SCALE" => Some(Self::Scale),
                "MIN_SCALE" => Some(Self::MinScale),
                "TRIM_SCALE" => Some(Self::TrimScale),
                "IS_TRUE" => Some(Self::IsTrue),
                "IS_NOT_TRUE" => Some(Self::IsNotTrue),
                "IS_FALSE" => Some(Self::IsFalse),
                "IS_NOT_FALSE" => Some(Self::IsNotFalse),
                "IS_NULL" => Some(Self::IsNull),
                "IS_NOT_NULL" => Some(Self::IsNotNull),
                "IS_DISTINCT_FROM" => Some(Self::IsDistinctFrom),
                "IS_NOT_DISTINCT_FROM" => Some(Self::IsNotDistinctFrom),
                "ENCODE" => Some(Self::Encode),
                "DECODE" => Some(Self::Decode),
                "SHA1" => Some(Self::Sha1),
                "SHA224" => Some(Self::Sha224),
                "SHA256" => Some(Self::Sha256),
                "SHA384" => Some(Self::Sha384),
                "SHA512" => Some(Self::Sha512),
                "LEFT" => Some(Self::Left),
                "RIGHT" => Some(Self::Right),
                "FORMAT" => Some(Self::Format),
                "FORMAT_VARIADIC" => Some(Self::FormatVariadic),
                "PGWIRE_SEND" => Some(Self::PgwireSend),
                "PGWIRE_RECV" => Some(Self::PgwireRecv),
                "CONVERT_FROM" => Some(Self::ConvertFrom),
                "CONVERT_TO" => Some(Self::ConvertTo),
                "DECRYPT" => Some(Self::Decrypt),
                "ENCRYPT" => Some(Self::Encrypt),
                "INET_ATON" => Some(Self::InetAton),
                "INET_NTOA" => Some(Self::InetNtoa),
                "QUOTE_LITERAL" => Some(Self::QuoteLiteral),
                "QUOTE_NULLABLE" => Some(Self::QuoteNullable),
                "HMAC" => Some(Self::Hmac),
                "SECURE_COMPARE" => Some(Self::SecureCompare),
                "CHECK_NOT_NULL" => Some(Self::CheckNotNull),
                "NEG" => Some(Self::Neg),
                "FIELD" => Some(Self::Field),
                "ARRAY" => Some(Self::Array),
                "ARRAY_ACCESS" => Some(Self::ArrayAccess),
                "ROW" => Some(Self::Row),
                "ARRAY_TO_STRING" => Some(Self::ArrayToString),
                "ARRAY_RANGE_ACCESS" => Some(Self::ArrayRangeAccess),
                "ARRAY_CAT" => Some(Self::ArrayCat),
                "ARRAY_APPEND" => Some(Self::ArrayAppend),
                "ARRAY_PREPEND" => Some(Self::ArrayPrepend),
                "FORMAT_TYPE" => Some(Self::FormatType),
                "ARRAY_DISTINCT" => Some(Self::ArrayDistinct),
                "ARRAY_LENGTH" => Some(Self::ArrayLength),
                "CARDINALITY" => Some(Self::Cardinality),
                "ARRAY_REMOVE" => Some(Self::ArrayRemove),
                "ARRAY_POSITIONS" => Some(Self::ArrayPositions),
                "TRIM_ARRAY" => Some(Self::TrimArray),
                "STRING_TO_ARRAY" => Some(Self::StringToArray),
                "ARRAY_POSITION" => Some(Self::ArrayPosition),
                "ARRAY_REPLACE" => Some(Self::ArrayReplace),
                "ARRAY_DIMS" => Some(Self::ArrayDims),
                "ARRAY_TRANSFORM" => Some(Self::ArrayTransform),
                "ARRAY_MIN" => Some(Self::ArrayMin),
                "ARRAY_MAX" => Some(Self::ArrayMax),
                "ARRAY_SUM" => Some(Self::ArraySum),
                "ARRAY_SORT" => Some(Self::ArraySort),
                "ARRAY_CONTAINS" => Some(Self::ArrayContains),
                "ARRAY_CONTAINED" => Some(Self::ArrayContained),
                "ARRAY_FLATTEN" => Some(Self::ArrayFlatten),
                "HEX_TO_INT256" => Some(Self::HexToInt256),
                "JSONB_ACCESS" => Some(Self::JsonbAccess),
                "JSONB_ACCESS_STR" => Some(Self::JsonbAccessStr),
                "JSONB_EXTRACT_PATH" => Some(Self::JsonbExtractPath),
                "JSONB_EXTRACT_PATH_VARIADIC" => Some(Self::JsonbExtractPathVariadic),
                "JSONB_EXTRACT_PATH_TEXT" => Some(Self::JsonbExtractPathText),
                "JSONB_EXTRACT_PATH_TEXT_VARIADIC" => {
                    Some(Self::JsonbExtractPathTextVariadic)
                }
                "JSONB_TYPEOF" => Some(Self::JsonbTypeof),
                "JSONB_ARRAY_LENGTH" => Some(Self::JsonbArrayLength),
                "IS_JSON" => Some(Self::IsJson),
                "JSONB_CONCAT" => Some(Self::JsonbConcat),
                "JSONB_OBJECT" => Some(Self::JsonbObject),
                "JSONB_PRETTY" => Some(Self::JsonbPretty),
                "JSONB_CONTAINS" => Some(Self::JsonbContains),
                "JSONB_CONTAINED" => Some(Self::JsonbContained),
                "JSONB_EXISTS" => Some(Self::JsonbExists),
                "JSONB_EXISTS_ANY" => Some(Self::JsonbExistsAny),
                "JSONB_EXISTS_ALL" => Some(Self::JsonbExistsAll),
                "JSONB_DELETE_PATH" => Some(Self::JsonbDeletePath),
                "JSONB_STRIP_NULLS" => Some(Self::JsonbStripNulls),
                "TO_JSONB" => Some(Self::ToJsonb),
                "JSONB_BUILD_ARRAY" => Some(Self::JsonbBuildArray),
                "JSONB_BUILD_ARRAY_VARIADIC" => Some(Self::JsonbBuildArrayVariadic),
                "JSONB_BUILD_OBJECT" => Some(Self::JsonbBuildObject),
                "JSONB_BUILD_OBJECT_VARIADIC" => Some(Self::JsonbBuildObjectVariadic),
                "JSONB_PATH_EXISTS" => Some(Self::JsonbPathExists),
                "JSONB_PATH_MATCH" => Some(Self::JsonbPathMatch),
                "JSONB_PATH_QUERY_ARRAY" => Some(Self::JsonbPathQueryArray),
                "JSONB_PATH_QUERY_FIRST" => Some(Self::JsonbPathQueryFirst),
                "JSONB_POPULATE_RECORD" => Some(Self::JsonbPopulateRecord),
                "JSONB_TO_RECORD" => Some(Self::JsonbToRecord),
                "JSONB_SET" => Some(Self::JsonbSet),
                "JSONB_POPULATE_MAP" => Some(Self::JsonbPopulateMap),
                "MAP_FROM_ENTRIES" => Some(Self::MapFromEntries),
                "MAP_ACCESS" => Some(Self::MapAccess),
                "MAP_KEYS" => Some(Self::MapKeys),
                "MAP_VALUES" => Some(Self::MapValues),
                "MAP_ENTRIES" => Some(Self::MapEntries),
                "MAP_FROM_KEY_VALUES" => Some(Self::MapFromKeyValues),
                "MAP_LENGTH" => Some(Self::MapLength),
                "MAP_CONTAINS" => Some(Self::MapContains),
                "MAP_CAT" => Some(Self::MapCat),
                "MAP_INSERT" => Some(Self::MapInsert),
                "MAP_DELETE" => Some(Self::MapDelete),
                "COMPOSITE_CAST" => Some(Self::CompositeCast),
                "VNODE" => Some(Self::Vnode),
                "TEST_PAID_TIER" => Some(Self::TestPaidTier),
                "VNODE_USER" => Some(Self::VnodeUser),
                "LICENSE" => Some(Self::License),
                "PROCTIME" => Some(Self::Proctime),
                "PG_SLEEP" => Some(Self::PgSleep),
                "PG_SLEEP_FOR" => Some(Self::PgSleepFor),
                "PG_SLEEP_UNTIL" => Some(Self::PgSleepUntil),
                "CAST_REGCLASS" => Some(Self::CastRegclass),
                "PG_GET_INDEXDEF" => Some(Self::PgGetIndexdef),
                "COL_DESCRIPTION" => Some(Self::ColDescription),
                "PG_GET_VIEWDEF" => Some(Self::PgGetViewdef),
                "PG_GET_USERBYID" => Some(Self::PgGetUserbyid),
                "PG_INDEXES_SIZE" => Some(Self::PgIndexesSize),
                "PG_RELATION_SIZE" => Some(Self::PgRelationSize),
                "PG_GET_SERIAL_SEQUENCE" => Some(Self::PgGetSerialSequence),
                "PG_INDEX_COLUMN_HAS_PROPERTY" => Some(Self::PgIndexColumnHasProperty),
                "HAS_TABLE_PRIVILEGE" => Some(Self::HasTablePrivilege),
                "HAS_ANY_COLUMN_PRIVILEGE" => Some(Self::HasAnyColumnPrivilege),
                "HAS_SCHEMA_PRIVILEGE" => Some(Self::HasSchemaPrivilege),
                "PG_IS_IN_RECOVERY" => Some(Self::PgIsInRecovery),
                "RW_RECOVERY_STATUS" => Some(Self::RwRecoveryStatus),
                "RW_EPOCH_TO_TS" => Some(Self::RwEpochToTs),
                "PG_TABLE_IS_VISIBLE" => Some(Self::PgTableIsVisible),
                "HAS_FUNCTION_PRIVILEGE" => Some(Self::HasFunctionPrivilege),
                "ICEBERG_TRANSFORM" => Some(Self::IcebergTransform),
                _ => None,
            }
        }
    }
    #[derive(::enum_as_inner::EnumAsInner)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum RexNode {
        #[prost(uint32, tag = "4")]
        InputRef(u32),
        #[prost(message, tag = "5")]
        Constant(super::super::data::Datum),
        #[prost(message, tag = "6")]
        FuncCall(super::FunctionCall),
        #[prost(message, tag = "7")]
        Udf(::prost::alloc::boxed::Box<super::UserDefinedFunction>),
        #[prost(message, tag = "8")]
        Now(NowRexNode),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TableFunction {
    #[prost(enumeration = "table_function::Type", tag = "1")]
    pub function_type: i32,
    #[prost(message, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<ExprNode>,
    #[prost(message, optional, tag = "3")]
    pub return_type: ::core::option::Option<super::data::DataType>,
    /// optional. only used when the type is USER_DEFINED.
    #[prost(message, optional, tag = "4")]
    pub udf: ::core::option::Option<UserDefinedFunctionMetadata>,
}
/// Nested message and enum types in `TableFunction`.
pub mod table_function {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        GenerateSeries = 1,
        Unnest = 2,
        RegexpMatches = 3,
        Range = 4,
        GenerateSubscripts = 5,
        /// buf:lint:ignore ENUM_VALUE_UPPER_SNAKE_CASE
        PgExpandarray = 6,
        PgGetKeywords = 18,
        /// Jsonb functions
        JsonbArrayElements = 10,
        JsonbArrayElementsText = 11,
        JsonbEach = 12,
        JsonbEachText = 13,
        JsonbObjectKeys = 14,
        JsonbPathQuery = 15,
        JsonbPopulateRecordset = 16,
        JsonbToRecordset = 17,
        /// file scan
        FileScan = 19,
        /// postgres query
        PostgresQuery = 20,
        /// mysql query
        MysqlQuery = 21,
        /// User defined table function
        UserDefined = 100,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::GenerateSeries => "GENERATE_SERIES",
                Self::Unnest => "UNNEST",
                Self::RegexpMatches => "REGEXP_MATCHES",
                Self::Range => "RANGE",
                Self::GenerateSubscripts => "GENERATE_SUBSCRIPTS",
                Self::PgExpandarray => "_PG_EXPANDARRAY",
                Self::PgGetKeywords => "PG_GET_KEYWORDS",
                Self::JsonbArrayElements => "JSONB_ARRAY_ELEMENTS",
                Self::JsonbArrayElementsText => "JSONB_ARRAY_ELEMENTS_TEXT",
                Self::JsonbEach => "JSONB_EACH",
                Self::JsonbEachText => "JSONB_EACH_TEXT",
                Self::JsonbObjectKeys => "JSONB_OBJECT_KEYS",
                Self::JsonbPathQuery => "JSONB_PATH_QUERY",
                Self::JsonbPopulateRecordset => "JSONB_POPULATE_RECORDSET",
                Self::JsonbToRecordset => "JSONB_TO_RECORDSET",
                Self::FileScan => "FILE_SCAN",
                Self::PostgresQuery => "POSTGRES_QUERY",
                Self::MysqlQuery => "MYSQL_QUERY",
                Self::UserDefined => "USER_DEFINED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "GENERATE_SERIES" => Some(Self::GenerateSeries),
                "UNNEST" => Some(Self::Unnest),
                "REGEXP_MATCHES" => Some(Self::RegexpMatches),
                "RANGE" => Some(Self::Range),
                "GENERATE_SUBSCRIPTS" => Some(Self::GenerateSubscripts),
                "_PG_EXPANDARRAY" => Some(Self::PgExpandarray),
                "PG_GET_KEYWORDS" => Some(Self::PgGetKeywords),
                "JSONB_ARRAY_ELEMENTS" => Some(Self::JsonbArrayElements),
                "JSONB_ARRAY_ELEMENTS_TEXT" => Some(Self::JsonbArrayElementsText),
                "JSONB_EACH" => Some(Self::JsonbEach),
                "JSONB_EACH_TEXT" => Some(Self::JsonbEachText),
                "JSONB_OBJECT_KEYS" => Some(Self::JsonbObjectKeys),
                "JSONB_PATH_QUERY" => Some(Self::JsonbPathQuery),
                "JSONB_POPULATE_RECORDSET" => Some(Self::JsonbPopulateRecordset),
                "JSONB_TO_RECORDSET" => Some(Self::JsonbToRecordset),
                "FILE_SCAN" => Some(Self::FileScan),
                "POSTGRES_QUERY" => Some(Self::PostgresQuery),
                "MYSQL_QUERY" => Some(Self::MysqlQuery),
                "USER_DEFINED" => Some(Self::UserDefined),
                _ => None,
            }
        }
    }
}
/// Reference to an upstream column, containing its index and data type.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InputRef {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<super::data::DataType>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Constant {
    #[prost(message, optional, tag = "1")]
    pub datum: ::core::option::Option<super::data::Datum>,
    #[prost(message, optional, tag = "2")]
    pub r#type: ::core::option::Option<super::data::DataType>,
}
/// The items which can occur in the select list of `ProjectSet` operator.
///
/// When there are table functions in the SQL query `SELECT ...`, it will be planned as `ProjectSet`.
/// Otherwise it will be planned as `Project`.
///
/// # Examples
///
/// ```sql
/// # Project
/// select 1;
///
/// # ProjectSet
/// select unnest(array\[1,2,3\]);
///
/// # ProjectSet (table function & usual expression)
/// select unnest(array\[1,2,3\]), 1;
///
/// # ProjectSet (multiple table functions)
/// select unnest(array\[1,2,3\]), unnest(array\[4,5\]);
///
/// # ProjectSet over ProjectSet (table function as parameters of table function)
/// select unnest(regexp_matches(v1, 'a(\d)c(\d)', 'g')) from t;
///
/// # Project over ProjectSet (table function as parameters of usual function)
/// select unnest(regexp_matches(v1, 'a(\d)c(\d)', 'g')) from t;
/// ```
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectSetSelectItem {
    #[prost(oneof = "project_set_select_item::SelectItem", tags = "1, 2")]
    pub select_item: ::core::option::Option<project_set_select_item::SelectItem>,
}
/// Nested message and enum types in `ProjectSetSelectItem`.
pub mod project_set_select_item {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum SelectItem {
        #[prost(message, tag = "1")]
        Expr(super::ExprNode),
        #[prost(message, tag = "2")]
        TableFunction(super::TableFunction),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FunctionCall {
    #[prost(message, repeated, tag = "1")]
    pub children: ::prost::alloc::vec::Vec<ExprNode>,
}
/// Aggregate Function Calls for Aggregation
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggCall {
    #[prost(enumeration = "agg_call::Kind", tag = "1")]
    pub kind: i32,
    #[prost(message, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<InputRef>,
    #[prost(message, optional, tag = "3")]
    pub return_type: ::core::option::Option<super::data::DataType>,
    #[prost(bool, tag = "4")]
    pub distinct: bool,
    #[prost(message, repeated, tag = "5")]
    pub order_by: ::prost::alloc::vec::Vec<super::common::ColumnOrder>,
    #[prost(message, optional, tag = "6")]
    pub filter: ::core::option::Option<ExprNode>,
    #[prost(message, repeated, tag = "7")]
    pub direct_args: ::prost::alloc::vec::Vec<Constant>,
    /// optional. only used when the kind is USER_DEFINED.
    #[prost(message, optional, tag = "8")]
    pub udf: ::core::option::Option<UserDefinedFunctionMetadata>,
    /// optional. only used when the kind is WRAP_SCALAR.
    #[prost(message, optional, tag = "9")]
    pub scalar: ::core::option::Option<ExprNode>,
}
/// Nested message and enum types in `AggCall`.
pub mod agg_call {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Kind {
        Unspecified = 0,
        Sum = 1,
        Min = 2,
        Max = 3,
        Count = 4,
        Avg = 5,
        StringAgg = 6,
        ApproxCountDistinct = 7,
        ArrayAgg = 8,
        FirstValue = 9,
        Sum0 = 10,
        VarPop = 11,
        VarSamp = 12,
        StddevPop = 13,
        StddevSamp = 14,
        BitAnd = 15,
        BitOr = 16,
        BitXor = 17,
        BoolAnd = 18,
        BoolOr = 19,
        JsonbAgg = 20,
        JsonbObjectAgg = 21,
        PercentileCont = 22,
        PercentileDisc = 23,
        Mode = 24,
        LastValue = 25,
        Grouping = 26,
        InternalLastSeenValue = 27,
        ApproxPercentile = 28,
        /// user defined aggregate function
        UserDefined = 100,
        /// wraps a scalar function that takes a list as input as an aggregate function.
        WrapScalar = 101,
    }
    impl Kind {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::Sum => "SUM",
                Self::Min => "MIN",
                Self::Max => "MAX",
                Self::Count => "COUNT",
                Self::Avg => "AVG",
                Self::StringAgg => "STRING_AGG",
                Self::ApproxCountDistinct => "APPROX_COUNT_DISTINCT",
                Self::ArrayAgg => "ARRAY_AGG",
                Self::FirstValue => "FIRST_VALUE",
                Self::Sum0 => "SUM0",
                Self::VarPop => "VAR_POP",
                Self::VarSamp => "VAR_SAMP",
                Self::StddevPop => "STDDEV_POP",
                Self::StddevSamp => "STDDEV_SAMP",
                Self::BitAnd => "BIT_AND",
                Self::BitOr => "BIT_OR",
                Self::BitXor => "BIT_XOR",
                Self::BoolAnd => "BOOL_AND",
                Self::BoolOr => "BOOL_OR",
                Self::JsonbAgg => "JSONB_AGG",
                Self::JsonbObjectAgg => "JSONB_OBJECT_AGG",
                Self::PercentileCont => "PERCENTILE_CONT",
                Self::PercentileDisc => "PERCENTILE_DISC",
                Self::Mode => "MODE",
                Self::LastValue => "LAST_VALUE",
                Self::Grouping => "GROUPING",
                Self::InternalLastSeenValue => "INTERNAL_LAST_SEEN_VALUE",
                Self::ApproxPercentile => "APPROX_PERCENTILE",
                Self::UserDefined => "USER_DEFINED",
                Self::WrapScalar => "WRAP_SCALAR",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "SUM" => Some(Self::Sum),
                "MIN" => Some(Self::Min),
                "MAX" => Some(Self::Max),
                "COUNT" => Some(Self::Count),
                "AVG" => Some(Self::Avg),
                "STRING_AGG" => Some(Self::StringAgg),
                "APPROX_COUNT_DISTINCT" => Some(Self::ApproxCountDistinct),
                "ARRAY_AGG" => Some(Self::ArrayAgg),
                "FIRST_VALUE" => Some(Self::FirstValue),
                "SUM0" => Some(Self::Sum0),
                "VAR_POP" => Some(Self::VarPop),
                "VAR_SAMP" => Some(Self::VarSamp),
                "STDDEV_POP" => Some(Self::StddevPop),
                "STDDEV_SAMP" => Some(Self::StddevSamp),
                "BIT_AND" => Some(Self::BitAnd),
                "BIT_OR" => Some(Self::BitOr),
                "BIT_XOR" => Some(Self::BitXor),
                "BOOL_AND" => Some(Self::BoolAnd),
                "BOOL_OR" => Some(Self::BoolOr),
                "JSONB_AGG" => Some(Self::JsonbAgg),
                "JSONB_OBJECT_AGG" => Some(Self::JsonbObjectAgg),
                "PERCENTILE_CONT" => Some(Self::PercentileCont),
                "PERCENTILE_DISC" => Some(Self::PercentileDisc),
                "MODE" => Some(Self::Mode),
                "LAST_VALUE" => Some(Self::LastValue),
                "GROUPING" => Some(Self::Grouping),
                "INTERNAL_LAST_SEEN_VALUE" => Some(Self::InternalLastSeenValue),
                "APPROX_PERCENTILE" => Some(Self::ApproxPercentile),
                "USER_DEFINED" => Some(Self::UserDefined),
                "WRAP_SCALAR" => Some(Self::WrapScalar),
                _ => None,
            }
        }
    }
}
/// The aggregation type.
///
/// Ideally this should be used to encode the Rust `AggCall::agg_type` field, but historically we
/// flattened it into multiple fields in proto `AggCall` - `kind` + `udf` + `scalar`. So this
/// `AggType` proto type is only used by `WindowFunction` currently.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AggType {
    #[prost(enumeration = "agg_call::Kind", tag = "1")]
    pub kind: i32,
    /// UDF metadata. Only present when the kind is `USER_DEFINED`.
    #[prost(message, optional, tag = "8")]
    pub udf_meta: ::core::option::Option<UserDefinedFunctionMetadata>,
    /// Wrapped scalar expression. Only present when the kind is `WRAP_SCALAR`.
    #[prost(message, optional, tag = "9")]
    pub scalar_expr: ::core::option::Option<ExprNode>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowFrame {
    #[prost(enumeration = "window_frame::Type", tag = "1")]
    pub r#type: i32,
    /// Deprecated since we introduced `RANGE` frame.
    #[deprecated]
    #[prost(message, optional, tag = "2")]
    pub start: ::core::option::Option<window_frame::Bound>,
    /// Deprecated since we introduced `RANGE` frame.
    #[deprecated]
    #[prost(message, optional, tag = "3")]
    pub end: ::core::option::Option<window_frame::Bound>,
    #[prost(enumeration = "window_frame::Exclusion", tag = "4")]
    pub exclusion: i32,
    #[prost(oneof = "window_frame::Bounds", tags = "10, 15, 20")]
    pub bounds: ::core::option::Option<window_frame::Bounds>,
}
/// Nested message and enum types in `WindowFrame`.
pub mod window_frame {
    /// Deprecated since we introduced `RANGE` frame.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Bound {
        #[prost(enumeration = "BoundType", tag = "1")]
        pub r#type: i32,
        #[prost(oneof = "bound::Offset", tags = "2, 3")]
        pub offset: ::core::option::Option<bound::Offset>,
    }
    /// Nested message and enum types in `Bound`.
    pub mod bound {
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Offset {
            #[prost(uint64, tag = "2")]
            Integer(u64),
            #[prost(message, tag = "3")]
            Datum(super::super::super::data::Datum),
        }
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RowsFrameBounds {
        #[prost(message, optional, tag = "1")]
        pub start: ::core::option::Option<RowsFrameBound>,
        #[prost(message, optional, tag = "2")]
        pub end: ::core::option::Option<RowsFrameBound>,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct RowsFrameBound {
        #[prost(enumeration = "BoundType", tag = "1")]
        pub r#type: i32,
        #[prost(uint64, optional, tag = "3")]
        pub offset: ::core::option::Option<u64>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeFrameBounds {
        #[prost(message, optional, tag = "1")]
        pub start: ::core::option::Option<RangeFrameBound>,
        #[prost(message, optional, tag = "2")]
        pub end: ::core::option::Option<RangeFrameBound>,
        #[prost(message, optional, tag = "10")]
        pub order_data_type: ::core::option::Option<super::super::data::DataType>,
        #[prost(message, optional, tag = "15")]
        pub order_type: ::core::option::Option<super::super::common::OrderType>,
        #[prost(message, optional, tag = "20")]
        pub offset_data_type: ::core::option::Option<super::super::data::DataType>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct RangeFrameBound {
        #[prost(enumeration = "BoundType", tag = "1")]
        pub r#type: i32,
        #[prost(message, optional, tag = "3")]
        pub offset: ::core::option::Option<super::super::data::Datum>,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct SessionFrameBounds {
        #[prost(message, optional, tag = "1")]
        pub gap: ::core::option::Option<super::super::data::Datum>,
        #[prost(message, optional, tag = "10")]
        pub order_data_type: ::core::option::Option<super::super::data::DataType>,
        #[prost(message, optional, tag = "15")]
        pub order_type: ::core::option::Option<super::super::common::OrderType>,
        #[prost(message, optional, tag = "20")]
        pub gap_data_type: ::core::option::Option<super::super::data::DataType>,
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Type {
        Unspecified = 0,
        /// Deprecated since we introduced `RANGE` frame.
        RowsLegacy = 2,
        Rows = 5,
        Range = 10,
        Session = 15,
    }
    impl Type {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "TYPE_UNSPECIFIED",
                Self::RowsLegacy => "TYPE_ROWS_LEGACY",
                Self::Rows => "TYPE_ROWS",
                Self::Range => "TYPE_RANGE",
                Self::Session => "TYPE_SESSION",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "TYPE_ROWS_LEGACY" => Some(Self::RowsLegacy),
                "TYPE_ROWS" => Some(Self::Rows),
                "TYPE_RANGE" => Some(Self::Range),
                "TYPE_SESSION" => Some(Self::Session),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum BoundType {
        Unspecified = 0,
        UnboundedPreceding = 1,
        Preceding = 2,
        CurrentRow = 3,
        Following = 4,
        UnboundedFollowing = 5,
    }
    impl BoundType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "BOUND_TYPE_UNSPECIFIED",
                Self::UnboundedPreceding => "BOUND_TYPE_UNBOUNDED_PRECEDING",
                Self::Preceding => "BOUND_TYPE_PRECEDING",
                Self::CurrentRow => "BOUND_TYPE_CURRENT_ROW",
                Self::Following => "BOUND_TYPE_FOLLOWING",
                Self::UnboundedFollowing => "BOUND_TYPE_UNBOUNDED_FOLLOWING",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "BOUND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
                "BOUND_TYPE_UNBOUNDED_PRECEDING" => Some(Self::UnboundedPreceding),
                "BOUND_TYPE_PRECEDING" => Some(Self::Preceding),
                "BOUND_TYPE_CURRENT_ROW" => Some(Self::CurrentRow),
                "BOUND_TYPE_FOLLOWING" => Some(Self::Following),
                "BOUND_TYPE_UNBOUNDED_FOLLOWING" => Some(Self::UnboundedFollowing),
                _ => None,
            }
        }
    }
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Exclusion {
        Unspecified = 0,
        CurrentRow = 1,
        /// EXCLUSION_GROUP = 2;
        /// EXCLUSION_TIES = 3;
        NoOthers = 4,
    }
    impl Exclusion {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "EXCLUSION_UNSPECIFIED",
                Self::CurrentRow => "EXCLUSION_CURRENT_ROW",
                Self::NoOthers => "EXCLUSION_NO_OTHERS",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "EXCLUSION_UNSPECIFIED" => Some(Self::Unspecified),
                "EXCLUSION_CURRENT_ROW" => Some(Self::CurrentRow),
                "EXCLUSION_NO_OTHERS" => Some(Self::NoOthers),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Bounds {
        #[prost(message, tag = "10")]
        Rows(RowsFrameBounds),
        #[prost(message, tag = "15")]
        Range(RangeFrameBounds),
        #[prost(message, tag = "20")]
        Session(SessionFrameBounds),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WindowFunction {
    #[prost(message, repeated, tag = "3")]
    pub args: ::prost::alloc::vec::Vec<InputRef>,
    #[prost(message, optional, tag = "4")]
    pub return_type: ::core::option::Option<super::data::DataType>,
    #[prost(message, optional, tag = "5")]
    pub frame: ::core::option::Option<WindowFrame>,
    #[prost(bool, tag = "6")]
    pub ignore_nulls: bool,
    #[prost(oneof = "window_function::Type", tags = "1, 2, 103")]
    pub r#type: ::core::option::Option<window_function::Type>,
}
/// Nested message and enum types in `WindowFunction`.
pub mod window_function {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum GeneralType {
        Unspecified = 0,
        RowNumber = 1,
        Rank = 2,
        DenseRank = 3,
        /// PERCENT_RANK = 4;
        /// CUME_DIST = 5;
        /// NTILE = 6;
        Lag = 7,
        Lead = 8,
    }
    impl GeneralType {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "UNSPECIFIED",
                Self::RowNumber => "ROW_NUMBER",
                Self::Rank => "RANK",
                Self::DenseRank => "DENSE_RANK",
                Self::Lag => "LAG",
                Self::Lead => "LEAD",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "UNSPECIFIED" => Some(Self::Unspecified),
                "ROW_NUMBER" => Some(Self::RowNumber),
                "RANK" => Some(Self::Rank),
                "DENSE_RANK" => Some(Self::DenseRank),
                "LAG" => Some(Self::Lag),
                "LEAD" => Some(Self::Lead),
                _ => None,
            }
        }
    }
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Type {
        #[prost(enumeration = "GeneralType", tag = "1")]
        General(i32),
        /// Deprecated since we have a new `aggregate2` variant.
        #[prost(enumeration = "super::agg_call::Kind", tag = "2")]
        Aggregate(i32),
        #[prost(message, tag = "103")]
        Aggregate2(super::AggType),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDefinedFunction {
    #[prost(message, repeated, tag = "1")]
    pub children: ::prost::alloc::vec::Vec<ExprNode>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "8")]
    pub arg_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub arg_types: ::prost::alloc::vec::Vec<super::data::DataType>,
    #[prost(string, tag = "4")]
    pub language: ::prost::alloc::string::String,
    /// The link to the external function service.
    #[prost(string, optional, tag = "5")]
    pub link: ::core::option::Option<::prost::alloc::string::String>,
    /// This is re-interpreted as `name_in_runtime`.
    #[prost(string, optional, tag = "6")]
    pub identifier: ::core::option::Option<::prost::alloc::string::String>,
    /// - If `language` is `javascript` or `python`, the source code of the function.
    #[prost(string, optional, tag = "7")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
    /// - If `language` is `rust` or `wasm`, the zstd-compressed wasm binary.
    #[prost(bytes = "vec", optional, tag = "10")]
    pub compressed_binary: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, tag = "9")]
    pub always_retry_on_network_error: bool,
    /// The runtime selected when multiple runtimes are available for the language. Now is not used.
    #[prost(string, optional, tag = "11")]
    pub runtime: ::core::option::Option<::prost::alloc::string::String>,
    /// additional options for javascript functions
    #[prost(bool, optional, tag = "13")]
    pub is_async: ::core::option::Option<bool>,
    #[prost(bool, optional, tag = "14")]
    pub is_batched: ::core::option::Option<bool>,
    #[prost(enumeration = "UdfExprVersion", tag = "1000")]
    pub version: i32,
}
/// Additional information for user defined table/aggregate functions.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UserDefinedFunctionMetadata {
    #[prost(string, repeated, tag = "8")]
    pub arg_names: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "3")]
    pub arg_types: ::prost::alloc::vec::Vec<super::data::DataType>,
    #[prost(message, optional, tag = "13")]
    pub return_type: ::core::option::Option<super::data::DataType>,
    #[prost(string, tag = "4")]
    pub language: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub link: ::core::option::Option<::prost::alloc::string::String>,
    /// This is re-interpreted as `name_in_runtime`.
    #[prost(string, optional, tag = "6")]
    pub identifier: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "7")]
    pub body: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(bytes = "vec", optional, tag = "10")]
    pub compressed_binary: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    #[prost(string, optional, tag = "11")]
    pub runtime: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(enumeration = "UdfExprVersion", tag = "1000")]
    pub version: i32,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum UdfExprVersion {
    /// Versions before introducing this enum.
    Unspecified = 0,
    /// Begin from this version, we re-interpret `identifier` as `name_in_runtime`.
    NameInRuntime = 1,
}
impl UdfExprVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "UDF_EXPR_VERSION_UNSPECIFIED",
            Self::NameInRuntime => "UDF_EXPR_VERSION_NAME_IN_RUNTIME",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "UDF_EXPR_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "UDF_EXPR_VERSION_NAME_IN_RUNTIME" => Some(Self::NameInRuntime),
            _ => None,
        }
    }
}
