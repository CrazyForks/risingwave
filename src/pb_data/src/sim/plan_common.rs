// This file is @generated by prost-build.
/// Field is a column in the streaming or batch plan.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Field {
    #[prost(message, optional, tag = "1")]
    pub data_type: ::core::option::Option<super::data::DataType>,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
#[prost(skip_debug)]
pub struct ColumnDesc {
    #[prost(message, optional, tag = "1")]
    pub column_type: ::core::option::Option<super::data::DataType>,
    #[prost(int32, tag = "2")]
    pub column_id: i32,
    /// we store the column name in column desc now just for debug, but in future
    /// we should store it in ColumnCatalog but not here
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    /// This field is used to store the description set by the `comment on` clause.
    #[prost(string, optional, tag = "8")]
    pub description: ::core::option::Option<::prost::alloc::string::String>,
    /// deprecated, use AdditionalColumn instead, keep for compatibility with v1.6.x
    #[prost(enumeration = "AdditionalColumnType", tag = "9")]
    pub additional_column_type: i32,
    #[prost(enumeration = "ColumnDescVersion", tag = "10")]
    pub version: i32,
    #[prost(message, optional, tag = "11")]
    pub additional_column: ::core::option::Option<AdditionalColumn>,
    #[prost(bool, tag = "12")]
    pub nullable: bool,
    /// Optional description for the generated column or default value.
    #[prost(oneof = "column_desc::GeneratedOrDefaultColumn", tags = "6, 7")]
    pub generated_or_default_column: ::core::option::Option<
        column_desc::GeneratedOrDefaultColumn,
    >,
}
/// Nested message and enum types in `ColumnDesc`.
pub mod column_desc {
    /// Optional description for the generated column or default value.
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    #[prost(skip_debug)]
    pub enum GeneratedOrDefaultColumn {
        #[prost(message, tag = "6")]
        GeneratedColumn(super::GeneratedColumnDesc),
        #[prost(message, tag = "7")]
        DefaultColumn(super::DefaultColumnDesc),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ColumnCatalog {
    #[prost(message, optional, tag = "1")]
    pub column_desc: ::core::option::Option<ColumnDesc>,
    #[prost(bool, tag = "2")]
    pub is_hidden: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GeneratedColumnDesc {
    #[prost(message, optional, tag = "1")]
    pub expr: ::core::option::Option<super::expr::ExprNode>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultColumnDesc {
    /// Expression of the `DEFAULT`. Used when inserting new records.
    #[prost(message, optional, tag = "1")]
    pub expr: ::core::option::Option<super::expr::ExprNode>,
    /// Evaluated value of the expression at the time of the table creation or the
    /// column addition. Used when filling the default value for the records where
    /// the column is missing.
    #[prost(message, optional, tag = "2")]
    pub snapshot_value: ::core::option::Option<super::data::Datum>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StorageTableDesc {
    #[prost(uint32, tag = "1")]
    pub table_id: u32,
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<ColumnDesc>,
    /// TODO: may refactor primary key representations
    #[prost(message, repeated, tag = "3")]
    pub pk: ::prost::alloc::vec::Vec<super::common::ColumnOrder>,
    #[prost(uint32, repeated, tag = "4")]
    pub dist_key_in_pk_indices: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, repeated, tag = "6")]
    pub value_indices: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, tag = "7")]
    pub read_prefix_len_hint: u32,
    /// Whether the table is versioned. If `true`, column-aware row encoding will
    /// be used to be compatible with schema changes.
    #[prost(bool, tag = "8")]
    pub versioned: bool,
    #[prost(uint32, repeated, tag = "9")]
    pub stream_key: ::prost::alloc::vec::Vec<u32>,
    #[prost(uint32, optional, tag = "10")]
    pub vnode_col_idx_in_pk: ::core::option::Option<u32>,
    #[prost(uint32, optional, tag = "11")]
    pub retention_seconds: ::core::option::Option<u32>,
    /// Total vnode count of the table.
    ///
    /// Can be unset if the table is created in older versions where variable vnode count is not
    /// supported, in which case a default value of 256 (or 1 for singleton) should be used.
    /// Use `VnodeCountCompat::vnode_count` to access it.
    #[prost(uint32, optional, tag = "12")]
    pub maybe_vnode_count: ::core::option::Option<u32>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsOf {
    #[prost(oneof = "as_of::AsOfType", tags = "1, 2, 3")]
    pub as_of_type: ::core::option::Option<as_of::AsOfType>,
}
/// Nested message and enum types in `AsOf`.
pub mod as_of {
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct ProcessTime {}
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Timestamp {
        #[prost(int64, tag = "1")]
        pub timestamp: i64,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Message)]
    pub struct Version {
        #[prost(int64, tag = "1")]
        pub version: i64,
    }
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum AsOfType {
        #[prost(message, tag = "1")]
        ProcessTime(ProcessTime),
        #[prost(message, tag = "2")]
        Timestamp(Timestamp),
        #[prost(message, tag = "3")]
        Version(Version),
    }
}
/// Represents a table in external database for CDC scenario
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalTableDesc {
    #[prost(uint32, tag = "1")]
    pub table_id: u32,
    #[prost(message, repeated, tag = "2")]
    pub columns: ::prost::alloc::vec::Vec<ColumnDesc>,
    /// TODO: may refactor primary key representations
    #[prost(message, repeated, tag = "3")]
    pub pk: ::prost::alloc::vec::Vec<super::common::ColumnOrder>,
    #[prost(string, tag = "4")]
    pub table_name: ::prost::alloc::string::String,
    #[prost(uint32, repeated, tag = "5")]
    pub stream_key: ::prost::alloc::vec::Vec<u32>,
    #[prost(btree_map = "string, string", tag = "6")]
    pub connect_properties: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// upstream cdc source job id
    #[prost(uint32, tag = "7")]
    pub source_id: u32,
    #[prost(btree_map = "string, message", tag = "8")]
    pub secret_refs: ::prost::alloc::collections::BTreeMap<
        ::prost::alloc::string::String,
        super::secret::SecretRef,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AsOfJoinDesc {
    /// The index of the right side's as of column.
    #[prost(uint32, tag = "1")]
    pub right_idx: u32,
    /// The index of the left side's as of column.
    #[prost(uint32, tag = "2")]
    pub left_idx: u32,
    /// The type of the inequality.
    #[prost(enumeration = "AsOfJoinInequalityType", tag = "3")]
    pub inequality_type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IndexAndExpr {
    #[prost(uint32, tag = "1")]
    pub index: u32,
    #[prost(message, optional, tag = "2")]
    pub expr: ::core::option::Option<super::expr::ExprNode>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefaultColumns {
    #[prost(message, repeated, tag = "1")]
    pub default_columns: ::prost::alloc::vec::Vec<IndexAndExpr>,
}
/// The cardinality of the output rows of a plan node. Bounds are inclusive.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct Cardinality {
    #[prost(uint64, tag = "1")]
    pub lo: u64,
    /// Unbounded if not set.
    #[prost(uint64, optional, tag = "2")]
    pub hi: ::core::option::Option<u64>,
}
/// Provide statement-local context, e.g. session info like time zone, for execution.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExprContext {
    #[prost(string, tag = "1")]
    pub time_zone: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub strict_mode: bool,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnKey {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnTimestamp {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnPartition {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnOffset {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnFilename {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalColumnHeader {
    #[prost(string, tag = "1")]
    pub inner_field: ::prost::alloc::string::String,
    #[prost(message, optional, tag = "2")]
    pub data_type: ::core::option::Option<super::data::DataType>,
}
/// metadata column for cdc table
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalDatabaseName {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalSchemaName {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalTableName {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalCollectionName {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnPayload {}
/// this type means we read all headers as a whole
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalColumnHeaders {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct AdditionalSubject {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdditionalColumn {
    #[prost(
        oneof = "additional_column::ColumnType",
        tags = "1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13"
    )]
    pub column_type: ::core::option::Option<additional_column::ColumnType>,
}
/// Nested message and enum types in `AdditionalColumn`.
pub mod additional_column {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum ColumnType {
        #[prost(message, tag = "1")]
        Key(super::AdditionalColumnKey),
        #[prost(message, tag = "2")]
        Timestamp(super::AdditionalColumnTimestamp),
        #[prost(message, tag = "3")]
        Partition(super::AdditionalColumnPartition),
        #[prost(message, tag = "4")]
        Offset(super::AdditionalColumnOffset),
        #[prost(message, tag = "5")]
        HeaderInner(super::AdditionalColumnHeader),
        #[prost(message, tag = "6")]
        Filename(super::AdditionalColumnFilename),
        #[prost(message, tag = "7")]
        Headers(super::AdditionalColumnHeaders),
        #[prost(message, tag = "8")]
        DatabaseName(super::AdditionalDatabaseName),
        #[prost(message, tag = "9")]
        SchemaName(super::AdditionalSchemaName),
        #[prost(message, tag = "10")]
        TableName(super::AdditionalTableName),
        #[prost(message, tag = "11")]
        CollectionName(super::AdditionalCollectionName),
        #[prost(message, tag = "12")]
        Payload(super::AdditionalColumnPayload),
        #[prost(message, tag = "13")]
        Subject(super::AdditionalSubject),
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ColumnDescVersion {
    Unspecified = 0,
    /// Introduced in <https://github.com/risingwavelabs/risingwave/pull/13707#discussion_r1429947537,>
    /// in case DEFAULT_KEY_COLUMN_NAME changes
    Pr13707 = 1,
}
impl ColumnDescVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "COLUMN_DESC_VERSION_UNSPECIFIED",
            Self::Pr13707 => "COLUMN_DESC_VERSION_PR_13707",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COLUMN_DESC_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "COLUMN_DESC_VERSION_PR_13707" => Some(Self::Pr13707),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum JoinType {
    /// Note that it comes from Calcite's JoinRelType.
    /// DO NOT HAVE direction for SEMI and ANTI now.
    Unspecified = 0,
    Inner = 1,
    LeftOuter = 2,
    RightOuter = 3,
    FullOuter = 4,
    LeftSemi = 5,
    LeftAnti = 6,
    RightSemi = 7,
    RightAnti = 8,
    AsofInner = 9,
    AsofLeftOuter = 10,
}
impl JoinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "JOIN_TYPE_UNSPECIFIED",
            Self::Inner => "JOIN_TYPE_INNER",
            Self::LeftOuter => "JOIN_TYPE_LEFT_OUTER",
            Self::RightOuter => "JOIN_TYPE_RIGHT_OUTER",
            Self::FullOuter => "JOIN_TYPE_FULL_OUTER",
            Self::LeftSemi => "JOIN_TYPE_LEFT_SEMI",
            Self::LeftAnti => "JOIN_TYPE_LEFT_ANTI",
            Self::RightSemi => "JOIN_TYPE_RIGHT_SEMI",
            Self::RightAnti => "JOIN_TYPE_RIGHT_ANTI",
            Self::AsofInner => "JOIN_TYPE_ASOF_INNER",
            Self::AsofLeftOuter => "JOIN_TYPE_ASOF_LEFT_OUTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "JOIN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "JOIN_TYPE_INNER" => Some(Self::Inner),
            "JOIN_TYPE_LEFT_OUTER" => Some(Self::LeftOuter),
            "JOIN_TYPE_RIGHT_OUTER" => Some(Self::RightOuter),
            "JOIN_TYPE_FULL_OUTER" => Some(Self::FullOuter),
            "JOIN_TYPE_LEFT_SEMI" => Some(Self::LeftSemi),
            "JOIN_TYPE_LEFT_ANTI" => Some(Self::LeftAnti),
            "JOIN_TYPE_RIGHT_SEMI" => Some(Self::RightSemi),
            "JOIN_TYPE_RIGHT_ANTI" => Some(Self::RightAnti),
            "JOIN_TYPE_ASOF_INNER" => Some(Self::AsofInner),
            "JOIN_TYPE_ASOF_LEFT_OUTER" => Some(Self::AsofLeftOuter),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AsOfJoinType {
    Unspecified = 0,
    Inner = 1,
    LeftOuter = 2,
}
impl AsOfJoinType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AS_OF_JOIN_TYPE_UNSPECIFIED",
            Self::Inner => "AS_OF_JOIN_TYPE_INNER",
            Self::LeftOuter => "AS_OF_JOIN_TYPE_LEFT_OUTER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AS_OF_JOIN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AS_OF_JOIN_TYPE_INNER" => Some(Self::Inner),
            "AS_OF_JOIN_TYPE_LEFT_OUTER" => Some(Self::LeftOuter),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AsOfJoinInequalityType {
    AsOfInequalityTypeUnspecified = 0,
    AsOfInequalityTypeGt = 1,
    AsOfInequalityTypeGe = 2,
    AsOfInequalityTypeLt = 3,
    AsOfInequalityTypeLe = 4,
}
impl AsOfJoinInequalityType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::AsOfInequalityTypeUnspecified => "AS_OF_INEQUALITY_TYPE_UNSPECIFIED",
            Self::AsOfInequalityTypeGt => "AS_OF_INEQUALITY_TYPE_GT",
            Self::AsOfInequalityTypeGe => "AS_OF_INEQUALITY_TYPE_GE",
            Self::AsOfInequalityTypeLt => "AS_OF_INEQUALITY_TYPE_LT",
            Self::AsOfInequalityTypeLe => "AS_OF_INEQUALITY_TYPE_LE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AS_OF_INEQUALITY_TYPE_UNSPECIFIED" => {
                Some(Self::AsOfInequalityTypeUnspecified)
            }
            "AS_OF_INEQUALITY_TYPE_GT" => Some(Self::AsOfInequalityTypeGt),
            "AS_OF_INEQUALITY_TYPE_GE" => Some(Self::AsOfInequalityTypeGe),
            "AS_OF_INEQUALITY_TYPE_LT" => Some(Self::AsOfInequalityTypeLt),
            "AS_OF_INEQUALITY_TYPE_LE" => Some(Self::AsOfInequalityTypeLe),
            _ => None,
        }
    }
}
/// <https://github.com/tokio-rs/prost/issues/80>
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FormatType {
    Unspecified = 0,
    Native = 1,
    Debezium = 2,
    DebeziumMongo = 3,
    Maxwell = 4,
    Canal = 5,
    Upsert = 6,
    Plain = 7,
    None = 8,
}
impl FormatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FORMAT_TYPE_UNSPECIFIED",
            Self::Native => "FORMAT_TYPE_NATIVE",
            Self::Debezium => "FORMAT_TYPE_DEBEZIUM",
            Self::DebeziumMongo => "FORMAT_TYPE_DEBEZIUM_MONGO",
            Self::Maxwell => "FORMAT_TYPE_MAXWELL",
            Self::Canal => "FORMAT_TYPE_CANAL",
            Self::Upsert => "FORMAT_TYPE_UPSERT",
            Self::Plain => "FORMAT_TYPE_PLAIN",
            Self::None => "FORMAT_TYPE_NONE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FORMAT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "FORMAT_TYPE_NATIVE" => Some(Self::Native),
            "FORMAT_TYPE_DEBEZIUM" => Some(Self::Debezium),
            "FORMAT_TYPE_DEBEZIUM_MONGO" => Some(Self::DebeziumMongo),
            "FORMAT_TYPE_MAXWELL" => Some(Self::Maxwell),
            "FORMAT_TYPE_CANAL" => Some(Self::Canal),
            "FORMAT_TYPE_UPSERT" => Some(Self::Upsert),
            "FORMAT_TYPE_PLAIN" => Some(Self::Plain),
            "FORMAT_TYPE_NONE" => Some(Self::None),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum EncodeType {
    Unspecified = 0,
    Native = 1,
    Avro = 2,
    Csv = 3,
    Protobuf = 4,
    Json = 5,
    Bytes = 6,
    Template = 7,
    None = 8,
    Text = 9,
    Parquet = 10,
}
impl EncodeType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ENCODE_TYPE_UNSPECIFIED",
            Self::Native => "ENCODE_TYPE_NATIVE",
            Self::Avro => "ENCODE_TYPE_AVRO",
            Self::Csv => "ENCODE_TYPE_CSV",
            Self::Protobuf => "ENCODE_TYPE_PROTOBUF",
            Self::Json => "ENCODE_TYPE_JSON",
            Self::Bytes => "ENCODE_TYPE_BYTES",
            Self::Template => "ENCODE_TYPE_TEMPLATE",
            Self::None => "ENCODE_TYPE_NONE",
            Self::Text => "ENCODE_TYPE_TEXT",
            Self::Parquet => "ENCODE_TYPE_PARQUET",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ENCODE_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ENCODE_TYPE_NATIVE" => Some(Self::Native),
            "ENCODE_TYPE_AVRO" => Some(Self::Avro),
            "ENCODE_TYPE_CSV" => Some(Self::Csv),
            "ENCODE_TYPE_PROTOBUF" => Some(Self::Protobuf),
            "ENCODE_TYPE_JSON" => Some(Self::Json),
            "ENCODE_TYPE_BYTES" => Some(Self::Bytes),
            "ENCODE_TYPE_TEMPLATE" => Some(Self::Template),
            "ENCODE_TYPE_NONE" => Some(Self::None),
            "ENCODE_TYPE_TEXT" => Some(Self::Text),
            "ENCODE_TYPE_PARQUET" => Some(Self::Parquet),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum RowFormatType {
    RowUnspecified = 0,
    Json = 1,
    Protobuf = 2,
    DebeziumJson = 3,
    Avro = 4,
    Maxwell = 5,
    CanalJson = 6,
    Csv = 7,
    Native = 8,
    DebeziumAvro = 9,
    UpsertJson = 10,
    UpsertAvro = 11,
    DebeziumMongoJson = 12,
    Bytes = 13,
}
impl RowFormatType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::RowUnspecified => "ROW_UNSPECIFIED",
            Self::Json => "JSON",
            Self::Protobuf => "PROTOBUF",
            Self::DebeziumJson => "DEBEZIUM_JSON",
            Self::Avro => "AVRO",
            Self::Maxwell => "MAXWELL",
            Self::CanalJson => "CANAL_JSON",
            Self::Csv => "CSV",
            Self::Native => "NATIVE",
            Self::DebeziumAvro => "DEBEZIUM_AVRO",
            Self::UpsertJson => "UPSERT_JSON",
            Self::UpsertAvro => "UPSERT_AVRO",
            Self::DebeziumMongoJson => "DEBEZIUM_MONGO_JSON",
            Self::Bytes => "BYTES",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ROW_UNSPECIFIED" => Some(Self::RowUnspecified),
            "JSON" => Some(Self::Json),
            "PROTOBUF" => Some(Self::Protobuf),
            "DEBEZIUM_JSON" => Some(Self::DebeziumJson),
            "AVRO" => Some(Self::Avro),
            "MAXWELL" => Some(Self::Maxwell),
            "CANAL_JSON" => Some(Self::CanalJson),
            "CSV" => Some(Self::Csv),
            "NATIVE" => Some(Self::Native),
            "DEBEZIUM_AVRO" => Some(Self::DebeziumAvro),
            "UPSERT_JSON" => Some(Self::UpsertJson),
            "UPSERT_AVRO" => Some(Self::UpsertAvro),
            "DEBEZIUM_MONGO_JSON" => Some(Self::DebeziumMongoJson),
            "BYTES" => Some(Self::Bytes),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AdditionalColumnType {
    Unspecified = 0,
    Key = 1,
    Timestamp = 2,
    Partition = 3,
    Offset = 4,
    Header = 5,
    Filename = 6,
    Normal = 7,
    Payload = 8,
}
impl AdditionalColumnType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ADDITIONAL_COLUMN_TYPE_UNSPECIFIED",
            Self::Key => "ADDITIONAL_COLUMN_TYPE_KEY",
            Self::Timestamp => "ADDITIONAL_COLUMN_TYPE_TIMESTAMP",
            Self::Partition => "ADDITIONAL_COLUMN_TYPE_PARTITION",
            Self::Offset => "ADDITIONAL_COLUMN_TYPE_OFFSET",
            Self::Header => "ADDITIONAL_COLUMN_TYPE_HEADER",
            Self::Filename => "ADDITIONAL_COLUMN_TYPE_FILENAME",
            Self::Normal => "ADDITIONAL_COLUMN_TYPE_NORMAL",
            Self::Payload => "ADDITIONAL_COLUMN_TYPE_PAYLOAD",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADDITIONAL_COLUMN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ADDITIONAL_COLUMN_TYPE_KEY" => Some(Self::Key),
            "ADDITIONAL_COLUMN_TYPE_TIMESTAMP" => Some(Self::Timestamp),
            "ADDITIONAL_COLUMN_TYPE_PARTITION" => Some(Self::Partition),
            "ADDITIONAL_COLUMN_TYPE_OFFSET" => Some(Self::Offset),
            "ADDITIONAL_COLUMN_TYPE_HEADER" => Some(Self::Header),
            "ADDITIONAL_COLUMN_TYPE_FILENAME" => Some(Self::Filename),
            "ADDITIONAL_COLUMN_TYPE_NORMAL" => Some(Self::Normal),
            "ADDITIONAL_COLUMN_TYPE_PAYLOAD" => Some(Self::Payload),
            _ => None,
        }
    }
}
